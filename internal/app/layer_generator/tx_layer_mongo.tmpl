// Code generated by "make app-layers"
// DO NOT EDIT
package {{.Package}}

import (
"context"

"github.com/kamva/hexa"
"github.com/kamva/tracer"
"go.mongodb.org/mongo-driver/mongo"
"space.org/space/internal/dto"
apperr "space.org/space/internal/error"
"space.org/space/internal/input"
"space.org/space/internal/store"
"space.org/space/internal/store/nosqlstore"
)


type {{.Name}} struct {
store store.Store
next  App
}

{{ range $methodName, $element := .Interface.Methods -}}

    func (a *{{$.Name}}) {{$methodName}}({{$element.Params | joinParamsWithType}}) {{joinResultsForSignatureInSameNameFormat $element.Results}} {
        {{ if not (hasAnnotation $element.Annotations "tx") -}}
            return a.next.{{$methodName}}({{$element.Params | joinParamsWithUnpack}})
        {{ else -}}

        cli, err := a.store.DBLayer().(nosqlstore.NoSqlStore).DBClient()
        if err != nil {
            {{$element.Results | errResultVar}} = tracer.Trace(err)
            return
        }

        sess := mongo.SessionFromContext(ctx)
        if sess == nil {
            sess, err = cli.StartSession()
            if err != nil {
                {{$element.Results | errResultVar}} = tracer.Trace(err)
                return
             }

            defer sess.EndSession(ctx)
        }

         _,  {{$element.Results | errResultVar}} = sess.WithTransaction(ctx, func(ctx mongo.SessionContext) (interface{}, error) {
                  {{$element.Results | genResultsVars}} = a.next.{{$methodName}}({{$element.Params | joinParamsWithUnpack}})
                  return nil, tracer.Trace({{$element.Results | errResultVar}})
         })
        {{$element.Results | errResultVar}}=tracer.Trace({{$element.Results | errResultVar}})
        return
        {{- end}}
    }
{{end}}

func New{{.Name | title}}(store store.Store,next App) App {
return &{{.Name}}{
store: store,
next: next,
}
}
