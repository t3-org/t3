// Code generated by "make app-layers"
// DO NOT EDIT
package {{.Store.Package}}

import (
"context"
"reflect"

"github.com/kamva/hexa"
"go.opentelemetry.io/otel/codes"
"go.opentelemetry.io/otel/trace"
apperr "t3.org/t3/internal/error"
"t3.org/t3/internal/model"
)

type {{.Store.Name}} struct {
next       model.Store
{{range $m,$subStore:=.SubStores}}
    {{- $subStore.InterfaceName}} {{$subStore.InterfaceType}}
{{end}}
}


{{range $idx,$method := .Store.Interface.Methods -}}
    func (s *{{$.Store.Name}}) {{$method.Name}}({{$method.Params | joinParamsWithType}}) {{joinResultsForSignature $method.Results}} {
    {{- if hasAnnotation $method.Annotations "subStore" -}}
        {{$subStore:=index $.SubStores $method.Name}}
        return s.{{$subStore.InterfaceName}}
    {{- else}}
        return s.next.{{$method.Name}}({{$method.Params | joinParamsWithUnpack}})
    {{- end}}
    }
{{end}}


func New{{.Store.Name | title}}(instrumentationPostfix string, tp trace.TracerProvider, next model.Store) model.Store {
pkgPath := reflect.TypeOf({{.Store.Name}}{}).PkgPath() + "." + instrumentationPostfix

return &{{.Store.Name}}{
next:       next,
{{range $m,$subStore:=.SubStores}}
    {{- $subStore.InterfaceName}}: &{{$subStore.Name}}{t: tp.Tracer(pkgPath), next: next.{{$subStore.StoreMethod.Name}}()},
{{end}}
}
}


//--------------------------------
// Define subStores
//--------------------------------

{{range $m,$subStore:=.SubStores}}

    type {{$subStore.Name}} struct {
    t trace.Tracer
    next       {{$subStore.InterfaceType}}
    }

    {{range $idx, $method := $subStore.Interface.Methods -}}
        func (s *{{$subStore.Name}}) {{$method.Name}}({{$method.Params | joinParamsWithType}}) {{joinResultsForSignature $method.Results}} {
        {{- if hasAnnotation $method.Annotations "noTracing" -}}
            return s.next.{{$method.Name}}({{$method.Params | joinParamsWithUnpack}})
        {{- else}}
            if ctx==nil{
            return s.next.{{$method.Name}}({{$method.Params | joinParamsWithUnpack}})
            }

            ctx, span := s.t.Start(ctx, "{{printf "%s.%s" $subStore.Interface.Name $method.Name}}")
            defer span.End()

            {{$method.Results | genResultsVars}} := s.next.{{$method.Name}}({{$method.Params | joinParamsWithUnpack}})

            {{- if $method.Results | hasErrInResults }}
                {{$errVarName:= $method.Results | errResultVar}}

                if apperr.IsInternalErr({{$errVarName}}){
                span.RecordError({{$errVarName}})
                span.SetStatus(codes.Error, {{$errVarName}}.Error())
                }else{
                span.SetStatus(codes.Ok, "")
                }
            {{- else}}
                span.SetStatus(codes.Ok, "")
            {{- end}}

            return {{$method.Results | genResultsVars -}}

        {{end}}
        }
    {{end}}
{{end}}
